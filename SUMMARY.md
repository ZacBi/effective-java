# Table of contents

* [引言](README.md)
* [Chapter 1. 创造和销毁对象](chapters/Chapter%201.%20创造和销毁对象.md)
  * [01. 考虑使用静态工厂方法替代构造方法](chapters/01.%20考虑使用静态工厂方法替代构造方法.md)
  * [02. 当构造方法参数过多时使用builder模式](chapters/02.%20当构造方法参数过多时使用builder模式.md)
  * [03. 使用私有构造方法或枚类实现Singleton属性](chapters/03.%20使用私有构造方法或枚类实现Singleton属性.md)
  * [04. 使用私有构造方法执行非实例化](chapters/04.%20使用私有构造方法执行非实例化.md)
  * [05. 依赖注入优于硬连接资源(hardwiring resources)](chapters/05.%20依赖注入优于硬连接资源.md)
  * [06. 避免创建不必要的对象](chapters/06.%20避免创建不必要的对象.md)
  * [07. 消除过期的对象引用](chapters/07.%20消除过期的对象引用.md)
  * [08. 避免使用Finalizer和Cleaner机制](chapters/08.%20避免使用Finalizer和Cleaner机制.md)
  * [09. 使用try-with-resources语句替代try-finally语句](chapters/09.%20使用try-with-resources语句替代try-finally语句.md)
* [Chapter 2. 所有对象通用方法](chapters/Chapter%202.%20所有对象通用方法.md)
  * [10. 重写equals方法时遵守通用约定](chapters/10.%20重写equals方法时遵守通用约定.md)
  * [11. 重写equals方法时同时也要重写hashcode方法](chapters/11.%20重写equals方法时同时也要重写hashcode方法.md)
  * [12. 始终重写 toString 方法](chapters/12.%20始终重写%20toString%20方法.md)
  * [13. 谨慎地重写 clone 方法](chapters/13.%20谨慎地重写%20clone%20方法.md)
  * [14. 考虑实现Comparable接口](chapters/14.%20考虑实现Comparable接口.md)
* [Chapter 3. 类与接口](Chapters/Chapter%203.%20类与接口.md)
  * [15. 使类和成员的可访问性最小化](chapters/15.%20使类和成员的可访问性最小化.md)
  * [16. 在公共类中使用访问方法而不是公共属性](chapters/16.%20在公共类中使用访问方法而不是公共属性.md)
  * [17. 最小化可变性](chapters/17.%20最小化可变性.md)
  * [18. 组合优于继承](chapters/18.%20组合优于继承.md)
  * [19. 要么设计继承并提供文档说明，要么禁用继承](chapters/19.%20要么设计继承并提供文档说明，要么禁用继承.md)
  * [20. 接口优于抽象类](chapters/20.%20接口优于抽象类.md)
  * [21. 为后代设计接口](chapters/21.%20为后代设计接口.md)
  * [22. 接口仅用来定义类型](chapters/22.%20接口仅用来定义类型.md)
  * [23. 类层次结构优于标签类](chapters/23.%20类层次结构优于标签类.md)
  * [24. 支持使用静态成员类而不是非静态类](chapters/24.%20支持使用静态成员类而不是非静态类.md)
  * [25. 将源文件限制为单个顶级类](chapters/25.%20将源文件限制为单个顶级类.md)
* [Chapter 4. 泛型](chapters/Chapter%204.%20泛型.md)
  * [26. 不要使用原始类型](chapters/26.%20不要使用原始类型.md)
  * [27. 消除非检查警告](chapters/27.%20消除非检查警告.md)
  * [28. 列表优于数组](chapters/28.%20列表优于数组.md)
  * [29. 优先考虑泛型](chapters/29.%20优先考虑泛型.md)
  * [30. 优先使用泛型方法](chapters/30.%20优先使用泛型方法.md)
  * [31. 使用限定通配符来增加API的灵活性](chapters/31.%20使用限定通配符来增加API的灵活性.md)
  * [32. 合理地结合泛型和可变参数](chapters/32.%20合理地结合泛型和可变参数.md)
  * [33. 优先考虑类型安全的异构容器](chapters/33.%20优先考虑类型安全的异构容器.md)
* [Chapter 5. 枚举与注解](chapters/Chapter%205.%20枚举与注解.md)
  * [34. 使用枚举类型替代整型常量](chapters/34.%20使用枚举类型替代整型常量.md)
  * [35. 使用实例属性替代序数](chapters/35.%20使用实例属性替代序数.md)
  * [36. 使用EnumSet替代位属性](chapters/36.%20使用EnumSet替代位属性.md)
  * [37. 使用EnumMap替代序数索引](chapters/37.%20使用EnumMap替代序数索引.md)
  * [38. 使用接口模拟可扩展的枚举](chapters/38.%20使用接口模拟可扩展的枚举.md)
  * [39. 注解优于命名模式](chapters/39.%20注解优于命名模式.md)
  * [40. 始终使用Override注解](chapters/40.%20始终使用Override注解.md)
  * [41. 使用标记接口定义类型](chapters/41.%20使用标记接口定义类型.md)
* [Chapter 6. Lambda表达式与流式编程](chapters/Chapter%206.%20Lambda表达式与流式编程.md)
  * [42. lambda表达式优于匿名类](chapters/42.%20lambda表达式优于匿名类.md)
  * [43. 方法引用优于lambda表达式](chapters/43.%20方法引用优于lambda表达式.md)
  * [44. 优先使用标准的函数式接口](chapters/44.%20优先使用标准的函数式接口.md)
  * [45. 明智审慎地使用Stream](chapters/45.%20明智审慎地使用Stream.md)
  * [46. 优先考虑流中无副作用的函数](chapters/46.%20优先考虑流中无副作用的函数.md)
  * [47. 优先使用Collection而不是Stream来作为方法的返回类型](chapters/47.%20优先使用Collection而不是Stream来作为方法的返回类型.md)
  * [48. 谨慎使用流并行](chapters/48.%20谨慎使用流并行.md)
* [Chapter 7. 方法](chapters/Chapter%207.%20方法.md)
  * [49. 检查参数有效性](chapters/49.%20检查参数有效性.md)
  * [50. 必要时进行防御性拷贝](chapters/50.%20必要时进行防御性拷贝.md)
  * [51. 仔细设计方法签名](chapters/51.%20仔细设计方法签名.md)
  * [52. 明智审慎地使用重载](chapters/52.%20明智审慎地使用重载.md)
  * [53. 明智审慎地使用可变参数](chapters/53.%20明智审慎地使用可变参数.md)
  * [54. 返回空的数组或集合，不要返回 null](chapters/54.%20返回空的数组或集合，不要返回%20null.md)
  * [55. 明智审慎地返回 Optional](chapters/55.%20明智审慎地返回%20Optional.md)
  * [56. 为所有已公开的 API 元素编写文档注释](chapters/56.%20为所有已公开的%20API%20元素编写文档注释.md)
* [Chapter 8. 通用程序设计](chapters/Chapter%208.%20通用程序设计.md)
  * [57. 最小化局部变量的作用域](chapters/57.%20最小化局部变量的作用域.md)
  * [58. for-each 循环优于传统 for 循环](chapters/58.%20for-each%20循环优于传统%20for%20循环.md)
  * [59. 了解并使用库](chapters/59.%20了解并使用库.md)
  * [60. 若需要精确答案就应避免使用 float 和 double 类型](chapters/60.%20若需要精确答案就应避免使用%20float%20和%20double%20类型.md)
  * [61. 基本数据类型优于包装类](chapters/61.%20基本数据类型优于包装类.md)
  * [62. 当使用其他类型更合适时应避免使用字符串](chapters/62.%20当使用其他类型更合适时应避免使用字符串.md)
  * [63. 当心字符串连接引起的性能问题](chapters/63.%20当心字符串连接引起的性能问题.md)
  * [64. 通过接口引用对象](chapters/64.%20通过接口引用对象.md)
  * [65. 接口优于反射](chapters/65.%20接口优于反射.md)
  * [66. 明智审慎地本地方法](chapters/66.%20明智审慎地本地方法.md)
  * [67. 明智审慎地进行优化](chapters/67.%20明智审慎地进行优化.md)
  * [68. 遵守被广泛认可的命名约定](chapters/68.%20遵守被广泛认可的命名约定.md)
* [Chapter 9. 异常](chapters/Chapter%209.%20异常.md)
  * [69. 只针对异常的情况下才使用异常](chapters/69.%20只针对异常的情况下才使用异常.md)
  * [70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常](chapters/70.%20对可恢复的情况使用受检异常，对编程错误使用运行时异常.md)
  * [71. 避免不必要的使用受检异常](chapters/71.%20避免不必要的使用受检异常.md)
  * [72. 优先使用标准的异常](chapters/72.%20优先使用标准的异常.md)
  * [73. 抛出与抽象对应的异常](chapters/73.%20抛出与抽象对应的异常.md)
  * [74. 每个方法抛出的异常都需要创建文档](chapters/74.%20每个方法抛出的异常都需要创建文档.md)
  * [75. 在细节消息中包含失败一捕获信息](chapters/75.%20在细节消息中包含失败一捕获信息.md)
  * [76. 保持失败原子性](chapters/76.%20保持失败原子性.md)
  * [77. 不要忽略异常](chapters/77.%20不要忽略异常.md)
* [Chapter 10. 并发](chapters/Chapter%2010.%20并发.md)
  * [78. 同步访问共享的可变数据](chapters/78.%20同步访问共享的可变数据.md)
  * [79. 避免过度同步](chapters/79.%20避免过度同步.md)
  * [80. executor 、task 和 stream 优先于线程](chapters/80.%20executor%20、task%20和%20stream%20优先于线程.md)
  * [81. 并发工具优于 wait 和 notify](chapters/81.%20并发工具优于%20wait%20和%20notify.md)
  * [82. 文档应包含线程安全属性](chapters/82.%20文档应包含线程安全属性.md)
  * [83. 明智审慎的使用延迟初始化](chapters/83.%20明智审慎的使用延迟初始化.md)
  * [84. 不要依赖线程调度器](chapters/84.%20不要依赖线程调度器.md)
* [Chapter 11. 序列化](chapters/Chapter%2011.%20序列化.md)
  * [85. 优先选择 Java 序列化的替代方案](chapters/85.%20优先选择%20Java%20序列化的替代方案.md)
  * [86. 非常谨慎地实现 Serializable](chapters/86.%20非常谨慎地实现%20Serializable.md)
  * [87. 考虑使用自定义的序列化形式](chapters/87.%20考虑使用自定义的序列化形式.md)
  * [88. 保护性的编写 readObject 方法](chapters/88.%20保护性的编写%20readObject%20方法.md)
  * [89. 对于实例控制，枚举类型优于 readResolve](chapters/89.%20对于实例控制，枚举类型优于%20readResolve.md)
  * [90. 考虑用序列化代理代替序列化实例](chapters/90.%20考虑用序列化代理代替序列化实例.md)